// /*********************************************************************
//  * DF Pong Controller
//  * 
//  * This program implements a Bluetooth Low Energy controller for Pong.
//  * It sends movement data to a central device running in the browser and
//  * provides audio feedback through a buzzer.
//  *
//  * Game Link : https://digitalfuturesocadu.github.io/df-pong/
//  * 
//  * Movement Values:
//  * 0 = No movement / Neutral position
//  * 1 = UP movement (paddle moves up)
//  * 2 = DOWN movement (paddle moves down)
//  * 3 = Handshake signal (used for initial connection verification)
//  * 
//  * Key Functions:
//  * - handleInput(): Process the inputs to generate the states
//  * - sendMovement(): Sends movement data over BLE (0-3)
//  * - updateBLE(): Handles BLE connection management and updates
//  * - updateBuzzer(): Provides different buzzer patterns for different movements
//  * 
//  * Key Variables:
//  * - currentMovement: Stores current movement state (0-2)
//  * - DEVICE_NUMBER: SET THIS TO YOUR ASSIGNED NUMBER (1-25)
//  * - LED_PIN : It is important to see the status of the arduino through the LED. 
//       if you can see the built-in add an external one and update the pin it is connected to
//  * 

//  *********************************************************************/


#include <ArduinoBLE.h>
#include "ble_functions.h"
#include "buzzer_functions.h"

// ============================================
// IMPORTANT: SET YOUR DEVICE NUMBER HERE (1-25)
// ============================================
const int DEVICE_NUMBER = 3;  // ‚Üê CHANGE THIS TO YOUR ASSIGNED NUMBER!
// ============================================

// Device name is generated from device number
String deviceNameStr = "DFPONG-" + String(DEVICE_NUMBER);
const char* deviceName = deviceNameStr.c_str();

// Pin definitions buzzer/LED
const int BUZZER_PIN = 11;       // Pin for haptic feedback buzzer
const int LED_PIN = LED_BUILTIN; // Status LED pin

// Movement state tracking
int currentMovement = 0;         // Current movement value (0=none, 1=up, 2=down)

// Analog pressure sensors
const int PRESSURE_DOWN_PIN = A7;  // Sensor for DOWN movement
const int PRESSURE_UP_PIN   = A5;  // Sensor for UP movement

// ADC and thresholds
const int ADC_MAX = 1023;               
const int PRESSURE_THRESHOLD_UP   = 600;               // Tune based on A5 sensor
const int PRESSURE_THRESHOLD_DOWN = 100;               // Tune based on A7 sensor
const int PRESSURE_HYSTERESIS     = ADC_MAX * 0.05;    // Reduce flicker, generated by GPT-5, on Dec 2nd, 2025

// Smoothing buffers (moving averages)
const int SMOOTH_SAMPLES = 5;

// UP sensor smoothing
int upSamples[SMOOTH_SAMPLES] = {0};
int upSampleIndex = 0;
bool upActive = false;   // latched state for UP

// DOWN sensor smoothing
int downSamples[SMOOTH_SAMPLES] = {0};
int downSampleIndex = 0;
bool downActive = false; // latched state for DOWN

void setup() 
{
  Serial.begin(9600);
  delay(1000); 
  Serial.println("=== DF Pong Controller Starting ===");
  
  // Configure analog inputs (pinMode optional for analogRead)
  pinMode(PRESSURE_UP_PIN, INPUT);
  pinMode(PRESSURE_DOWN_PIN, INPUT);

  // LED for connection status
  pinMode(LED_PIN, OUTPUT);
  
  // Initialize BLE and buzzer
  setupBLE(deviceName, DEVICE_NUMBER, LED_PIN);
  setupBuzzer(BUZZER_PIN);

  // Prime smoothing buffers with initial readings
  for (int i = 0; i < SMOOTH_SAMPLES; i++) {
    upSamples[i]   = analogRead(PRESSURE_UP_PIN);
    downSamples[i] = analogRead(PRESSURE_DOWN_PIN);
  }
}

void loop() 
{
  updateBLE();
  handleInput();
  sendMovement(currentMovement);
  updateBuzzer(currentMovement);
}

int readSmoothedPressure(int pin, int samples[], int& index) {
  // Simple moving average per sensor
  int raw = analogRead(pin);
  samples[index] = raw;
  index = (index + 1) % SMOOTH_SAMPLES; //Read samples by the index number

  long sum = 0;
  for (int i = 0; i < SMOOTH_SAMPLES; i++) sum += samples[i];
  return (int)(sum / SMOOTH_SAMPLES);
}

void handleInput() 
{
  // Read smoothed values
  int upPressure   = readSmoothedPressure(PRESSURE_UP_PIN, upSamples, upSampleIndex);
  int downPressure = readSmoothedPressure(PRESSURE_DOWN_PIN, downSamples, downSampleIndex);

  // Hysteresis levels
  int upOnLevel   = PRESSURE_THRESHOLD_UP;
  int upOffLevel  = PRESSURE_THRESHOLD_UP   - PRESSURE_HYSTERESIS;
  int downOnLevel = PRESSURE_THRESHOLD_DOWN;
  int downOffLevel= PRESSURE_THRESHOLD_DOWN - PRESSURE_HYSTERESIS;

  // UP hysteresis latch (A5)
  if (!upActive && upPressure <= upOnLevel) {
    upActive = true;
  } else if (upActive && upPressure > upOffLevel) {
    upActive = false;
  }

  // DOWN hysteresis latch (A7)
  if (!downActive && downPressure <= downOnLevel) {
    downActive = true;
  } else if (downActive && downPressure > downOffLevel) {
    downActive = false;
  }

  // Resolve movement: prefer a direction if only one is active
  // If both are active (both pressed), treat as no movement to avoid conflict,
  // Idea generated by GPT-5, Dec 2nd, 2025
  if (upActive && !downActive) {
    currentMovement = 1;  // UP movement
  } else if (downActive && !upActive) {
    currentMovement = 2;  // DOWN movement
  } else {
    currentMovement = 0;  // No movement (or both active)
  }

  // Debug prints to help tune thresholds
  Serial.print("UP(A5): ");
  Serial.print(upPressure);
  Serial.print(" | upActive: ");
  Serial.print(upActive);
  Serial.print(" || DOWN(A7): ");
  Serial.print(downPressure);
  Serial.print(" | downActive: ");
  Serial.print(downActive);
  Serial.print(" || currentMovement: ");
  Serial.println(currentMovement);
}
